<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Introduction to Algorithms and Time Complexity</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        line-height: 1.6;
        margin: 20px;
      }
      h1,
      h2 {
        color: #333;
      }
      pre {
        background: #f4f4f4;
        padding: 10px;
        border-radius: 5px;
        overflow-x: auto;
      }
      table {
        width: 100%;
        border-collapse: collapse;
        margin: 20px 0;
      }
      table,
      th,
      td {
        border: 1px solid #ddd;
      }
      th,
      td {
        padding: 10px;
        text-align: left;
      }
      th {
        background: #f4f4f4;
      }
      .highlight {
        font-weight: bold;
        color: #007acc;
      }
    </style>
  </head>
  <body>
    <h1>Introduction to Algorithms and Time Complexity</h1>

    <h2>üìö What is an Algorithm?</h2>
    <p>
      An <span class="highlight">algorithm</span> is simply a step-by-step set
      of instructions to solve a specific problem. Think of it like a recipe for
      baking a cake or a checklist to assemble furniture. In coding, algorithms
      help us write efficient programs to solve problems like searching for an
      item in a list, sorting data, or finding the shortest route between two
      points.
    </p>

    <hr />

    <h2>‚è±Ô∏è What is Time Complexity?</h2>
    <p>
      When we write an algorithm, we want to know how much time it will take to
      complete. <span class="highlight">Time complexity</span> measures how the
      running time of an algorithm increases as the size of the input grows.
    </p>
    <p>For example:</p>
    <ul>
      <li>
        Searching for your name in a list of 10 names takes less time than
        searching in a list of 1,000 names.
      </li>
      <li>Sorting 100 numbers takes less time than sorting 10,000 numbers.</li>
    </ul>
    <p>
      Time complexity is expressed using
      <span class="highlight">Big O Notation</span>, which gives us an idea of
      the algorithm's performance as the input size grows larger.
    </p>

    <hr />

    <h2>Why is Time Complexity Important?</h2>
    <ul>
      <li>
        <span class="highlight">Efficiency matters</span>: Faster algorithms
        save time and computing resources.
      </li>
      <li>
        <span class="highlight">Scalability</span>: Some algorithms work well
        for small inputs but become too slow for large inputs.
      </li>
    </ul>
    <p>
      Understanding time complexity helps you choose the right approach for your
      problem.
    </p>

    <hr />

    <h2>Examples of Time Complexities</h2>
    <table>
      <thead>
        <tr>
          <th>Time Complexity</th>
          <th>Description</th>
          <th>Analogy</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><span class="highlight">O(1)</span></td>
          <td>Constant time</td>
          <td>Finding the first page of a book ‚Äî you just open the cover.</td>
        </tr>
        <tr>
          <td><span class="highlight">O(log n)</span></td>
          <td>Logarithmic time</td>
          <td>
            Searching for a word in a dictionary by dividing it into halves.
          </td>
        </tr>
        <tr>
          <td><span class="highlight">O(n)</span></td>
          <td>Linear time</td>
          <td>Reading a book page by page.</td>
        </tr>
        <tr>
          <td><span class="highlight">O(n log n)</span></td>
          <td>Linearithmic time</td>
          <td>Organizing books using divide-and-conquer strategies.</td>
        </tr>
        <tr>
          <td><span class="highlight">O(n¬≤)</span></td>
          <td>Quadratic time</td>
          <td>
            Comparing every page in one book with every page in another book.
          </td>
        </tr>
        <tr>
          <td><span class="highlight">O(2‚Åø)</span></td>
          <td>Exponential time</td>
          <td>
            Doubling your task every step, like adding a new branch to a
            decision tree.
          </td>
        </tr>
        <tr>
          <td><span class="highlight">O(n!)</span></td>
          <td>Factorial time</td>
          <td>Trying every possible combination of books on a shelf.</td>
        </tr>
      </tbody>
    </table>

    <hr />

    <h2>üõ†Ô∏è Code Examples</h2>

    <h3>O(1): Constant Time Complexity</h3>
    <pre>
<code>
const arr = [1, 2, 3, 4, 5];
console.log(arr[2]); // 3
</code>
  </pre>

    <h3>O(log n): Logarithmic Time Complexity</h3>
    <pre>
<code>
function binarySearch(arr, target) {
  let left = 0, right = arr.length - 1;
  while (left <= right) {
    let mid = Math.floor((left + right) / 2);
    if (arr[mid] === target) return mid;
    else if (arr[mid] < target) left = mid + 1;
    else right = mid - 1;
  }
  return -1;
}

console.log(binarySearch([1, 2, 3, 4, 5], 3)); // 2
</code>
  </pre>

    <h3>O(n): Linear Time Complexity</h3>
    <pre>
<code>
function findElement(arr, target) {
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] === target) return i;
  }
  return -1;
}

console.log(findElement([1, 2, 3, 4, 5], 3)); // 2
</code>
  </pre>

    <h3>O(n log n): Linearithmic Time Complexity</h3>
    <pre>
<code>
function mergeSort(arr) {
  if (arr.length <= 1) return arr;
  const mid = Math.floor(arr.length / 2);
  const left = mergeSort(arr.slice(0, mid));
  const right = mergeSort(arr.slice(mid));
  return merge(left, right);
}

function merge(left, right) {
  const result = [];
  while (left.length && right.length) {
    if (left[0] < right[0]) result.push(left.shift());
    else result.push(right.shift());
  }
  return result.concat(left, right);
}

console.log(mergeSort([4, 2, 7, 1, 3])); // [1, 2, 3, 4, 7]
</code>
  </pre>

    <h3>O(n¬≤): Quadratic Time Complexity</h3>
    <pre>
<code>
function hasDuplicates(arr) {
  for (let i = 0; i < arr.length; i++) {
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[i] === arr[j]) return true;
    }
  }
  return false;
}

console.log(hasDuplicates([1, 2, 3, 4, 2])); // true
</code>
  </pre>

    <h3>O(2‚Åø): Exponential Time Complexity</h3>
    <pre>
<code>
function fibonacci(n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}

console.log(fibonacci(5)); // 5
</code>
  </pre>

    <h3>O(n!): Factorial Time Complexity</h3>
    <pre>
<code>
function permute(arr) {
  if (arr.length === 0) return [[]];
  const result = [];
  for (let i = 0; i < arr.length; i++) {
    const rest = [...arr.slice(0, i), ...arr.slice(i + 1)];
    for (let perm of permute(rest)) {
      result.push([arr[i], ...perm]);
    }
  }
  return result;
}

console.log(permute([1, 2, 3])); // [[1,2,3], [1,3,2], ...]
</code>
  </pre>

    <hr />

    <h2>Optimizations</h2>
    <ul>
      <li>
        <span class="highlight">Memoization</span>: Avoid redundant
        calculations, e.g., in Fibonacci.
      </li>
      <li>
        <span class="highlight">Divide and Conquer</span>: Use efficient sorting
        algorithms like merge sort.
      </li>
      <li>
        <span class="highlight">Data Structures</span>: Use hash maps for faster
        lookups.
      </li>
    </ul>
  </body>
</html>
